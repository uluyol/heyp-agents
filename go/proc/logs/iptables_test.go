package logs

import (
	"bytes"
	"strings"
	"testing"
)

func TestIPTFieldParser(t *testing.T) {
	tests := []struct {
		rec      string
		wantRule EnforcementRule
		wantRet  bool
		wantErr  string
	}{
		{"", EnforcementRule{}, false, "unknown rec"},
		{":INPUT ACCEPT [243873:14313830		", EnforcementRule{}, false, "unknown rec"},
		{
			rec:      "-A OUTPUT -d 192.168.1.3/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x12",
			wantRule: EnforcementRule{"192.168.1.3", "0x12", TCHandle{}},
		},
		{
			rec:     "-I OUTPUT -d 192.168.1.3/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x12",
			wantErr: "found -I rule",
		},
		{
			rec:      "-A OUTPUT -d 192.168.1.3/32 -o eno50 -p tcp -m tcp -j RETURN",
			wantRule: EnforcementRule{"192.168.1.3", "", TCHandle{}},
			wantRet:  true,
		},
	}

	for _, test := range tests {
		p := iptFieldParser{fields: bytes.Fields([]byte(test.rec))}
		r, didRet, err := p.ParseRule()
		if test.wantErr != "" {
			if err == nil || !strings.Contains(err.Error(), test.wantErr) {
				t.Errorf("input %q: expected error but got %v", test.rec, r)
			}
		} else {
			if err != nil {
				t.Errorf("input %q: unexpected error: %v", test.rec, err)
			}
			if r != test.wantRule {
				t.Errorf("input %q: got %v, want %v", test.rec, r, test.wantRule)
			}
			if didRet != test.wantRet {
				t.Errorf("input %q: didRet %t, wantRet %t", test.rec, didRet, test.wantRet)
			}
		}
	}
}

func TestIPTablesEnforcementRules(t *testing.T) {
	tests := []struct {
		name   string
		input  string
		output []EnforcementRule
	}{
		{
			name:   "empty",
			input:  ``,
			output: []EnforcementRule{},
		},
		{
			name:   "newline",
			input:  "\n",
			output: []EnforcementRule{},
		},
		{
			name: "multiple-blank-lines",
			input: `

			
`,
			output: []EnforcementRule{},
		},
		{
			name: "mostly-real-input-weird-whitespace",
			input: `
			# Generated by iptables-save v1.8.4 on Fri Jul  9 09:13:15 2021
			*mangle
			:PREROUTING ACCEPT [243874:14313882]
:INPUT ACCEPT [243873:14313830]
			:FORWARD ACCEPT [0:0]
			:OUTPUT ACCEPT [274732:1361337161]
			:POSTROUTING ACCEPT [274732:1361337161]
-A OUTPUT -d 192.168.1.2/32 -o eno50 -p tcp -m tcp -j CLASSIFY --set-class 0001:0002
			-A OUTPUT -d 192.168.1.2/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x12
			-A OUTPUT -d 192.168.1.2/32 -o eno50 -p tcp -m tcp -j RETURN
	-A OUTPUT -d 192.168.1.3/32 -o eno50 -p tcp -m tcp -j CLASSIFY --set-class 0001:0003
			-A OUTPUT -d 192.168.1.3/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x11
			-A OUTPUT -d 192.168.1.3/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x15
			-A OUTPUT -d 192.168.1.3/32 -o eno50 -p tcp -m tcp -j RETURN
			-A OUTPUT -d 192.168.1.5/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x10
			COMMIT
			# Completed on Fri Jul  9 09:13:15 2021
		
`,
			output: []EnforcementRule{
				{DstIP: "192.168.1.2", QoS: "0x12", ClassID: TCHandle{1, 2}},
				{DstIP: "192.168.1.3", QoS: "0x15", ClassID: TCHandle{1, 3}},
				{DstIP: "192.168.1.5", QoS: "0x10", ClassID: TCHandle{}},
			},
		},
		{
			name: "ignore-post-return",
			input: `
				# Generated by iptables-save v1.8.4 on Fri Jul  9 09:13:15 2021
				*mangle
				:PREROUTING ACCEPT [243874:14313882]
				:INPUT ACCEPT [243873:14313830]
				:FORWARD ACCEPT [0:0]
				:OUTPUT ACCEPT [274732:1361337161]
				:POSTROUTING ACCEPT [274732:1361337161]
				-A OUTPUT -d 192.168.1.2/32 -o eno50 -p tcp -m tcp -j CLASSIFY --set-class 0001:0002
				-A OUTPUT -d 192.168.1.2/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x12
				-A OUTPUT -d 192.168.1.2/32 -o eno50 -p tcp -m tcp -j RETURN
				-A OUTPUT -d 192.168.1.2/32 -o eno50 -p tcp -m tcp -j DSCP --set-dscp 0x00
				COMMIT
				# Completed on Fri Jul  9 09:13:15 2021`,
			output: []EnforcementRule{
				{DstIP: "192.168.1.2", QoS: "0x12", ClassID: TCHandle{1, 2}},
			},
		},
	}

	for _, test := range tests {
		recs, err := ReadIPTablesEnforcementRules(strings.NewReader(test.input))
		if err != nil {
			t.Errorf("input %q\n got unexpected error: %v", test.input, err)
		} else {
			repErr := func() {
				t.Helper()
				t.Errorf("input %q\n got %v, want %v", test.input, recs, test.output)
			}
			if len(recs) != len(test.output) {
				repErr()
			} else {
				for i := 0; i < len(test.output); i++ {
					if recs[i] != test.output[i] {
						repErr()
					}
				}
			}
		}
	}
}
