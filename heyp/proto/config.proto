// This file contains definitions of all configuration protos.
// These messages should only be stored in textual or in-memory form (i.e. not
// the binary format), so feed free to change any field numbers.

syntax = "proto2";

package heyp.proto;

option go_package = "github.com/uluyol/heyp-agents/go/pb";

import "heyp/proto/heyp.proto";

message DemandPredictorConfig {
  optional string time_window_dur = 1 [default = "10s"];
  optional double usage_multiplier = 2 [default = 1.1];
  optional int64 min_demand_bps = 3 [default = 5242880];
}

message HostFlowTrackerConfig {
  optional DemandPredictorConfig demand_predictor = 1;
  optional bool ignore_instantaneous_usage = 2 [default = true];
}

message FlowAggregatorConfig {
  optional DemandPredictorConfig demand_predictor = 1;
}

message HostFlowStateReporterConfig {
  optional string ss_binary_name = 1 [default = "ss"];
}

message HostEnforcerConfig {
  // If specified, will periodically dump iptables and tc state here.
  optional string debug_log_dir = 1;
  optional bool limit_hipri = 2 [default = true];
  optional bool limit_lopri = 3 [default = true];
  optional int64 pacing_burst_bytes = 4;

  // HostEnforcer will never drop rate limits below min_rate_limit_bps.
  optional int64 min_rate_limit_bps = 5 [default = 5242880];

  optional string dscp_hipri = 6 [default = "AF21"];
  optional string dscp_lopri = 7 [default = "BE"];
}

message HostDaemonConfig {
  optional string collect_stats_period = 1 [default = "500ms"];
  optional string inform_period_dur = 2 [default = "2s"];
  optional string cluster_agent_addr = 3;
  optional string cluster_agent_connection_timeout_dur = 4 [default = "10s"];

  // Log files - will record data once per collect_stats_period.
  //
  // - stats_log_file: src/dst host-level flow data
  // - fine_grained_stats_log_file: fine grained flow data
  //
  // If unspecified, data will not be logged.
  optional string stats_log_file = 5;
  optional string fine_grained_stats_log_file = 6;
}

message DCMapping {
  message Entry {
    optional string host_addr = 1;
    optional string dc = 2;
  }
  repeated Entry entries = 1;
}

message StaticDCMapperConfig {
  optional DCMapping mapping = 1;
}

enum NetemDelayDist {
  NETEM_NO_DIST = 0;
  NETEM_NORMAL = 1;
  NETEM_UNIFORM = 2;
  NETEM_PARETO = 3;
  NETEM_PARETONORMAL = 4;
}

message NetemConfig {
  optional int32 delay_ms = 1;
  optional int32 delay_jitter_ms = 2;
  optional double delay_correlation_pct = 3;
  optional NetemDelayDist delay_dist = 4 [default = NETEM_NORMAL];
}

message SimulatedWanConfig {
  message Pair {
    optional string src_dc = 1;
    optional string dst_dc = 2;
    optional NetemConfig netem = 3;
    optional NetemConfig netem_lopri = 4; // if unspecified, defaults to netem
  }
  repeated Pair dc_pairs = 1;
}

message HostAgentConfig {
  repeated string this_host_addrs = 1;
  optional string job_name = 2 [default = "UNSET"];
  optional HostFlowTrackerConfig flow_tracker = 3;
  optional FlowAggregatorConfig socket_to_host_aggregator = 4;
  optional HostFlowStateReporterConfig flow_state_reporter = 5;
  optional HostEnforcerConfig enforcer = 6;
  optional HostDaemonConfig daemon = 7;
  optional StaticDCMapperConfig dc_mapper = 8;
  optional SimulatedWanConfig simulated_wan = 9;
}

enum ClusterAllocatorType {
  CA_NOP = 0;
  CA_BWE = 1;
  CA_HEYP_SIGCOMM20 = 2;
  CA_SIMPLE_DOWNGRADE = 3;
  CA_FIXED_HOST_PATTERN = 4;
}

enum DowngradeSelectorType {
  DS_HEYP_SIGCOMM20 = 0;
  DS_HASHING = 1;
  DS_HYBRID_HASHING = 2;  // TODO: implement
  DS_KNAPSACK_SOLVER = 3;
  DS_LARGEST_FIRST = 4;
};

message DowngradeSelector {
  optional DowngradeSelectorType type = 1 [default = DS_HEYP_SIGCOMM20];

  // If set, will downgrade using usage as input not predicted demand.
  optional bool downgrade_usage = 2 [default = true];

  // If set, the DowngradeSelector will identify jobs to downgrade and mark all hosts
  // within those jobs as LOPRI.
  // Otherwise, it will select hosts without looking at which job a host belongs to.
  optional bool downgrade_jobs = 3 [default = false];

  // If >0, the solver will stop computing after time_limit_sec.
  // Useful for computationally-expensive solvers.
  optional double time_limit_sec = 4 [default = -1];

  message HybridHashingConfig {
    // num_demand_aware is the number of hosts that will have their QoS set
    // explicitly based on demand data.
    optional int32 num_demand_aware = 1 [default = 100];

    // min_qos_pin_ms is the minimum amount of time a host will stay at
    // a given QoS. Until then, a host that has been explicitly selected
    // for HIPRI/LOPRI will retain that QoS. Afterward, the QoS may change.
    optional int64 min_qos_pin_ms = 2 [default = 1000];
  }

  // Used when type == DS_HYBRID_HASHING
  optional HybridHashingConfig hybrid_hashing = 5;
}

// DowngradeFracController is a feedback controller that computes
// 'diffs' of how much additional traffic should downgraded
// (a negative value indicates that traffic should be upgraded).
message DowngradeFracController {
  // Diffs will be capped to have an absolute value of at most max_inc.
  optional double max_inc = 1 [default = 1];

  // prop_gain is a value ranging from 0 to 1 that indicates how much
  // of the error we should try to address in one control period.
  optional double prop_gain = 2 [default = 0.75];

  // If the overage is below ignore_overage_below, we return a diff of 0.
  optional double ignore_overage_below = 3;

  // If the overage is below ignore_overage_by_coarseness_multiplier * max task usage,
  // we ignore it.
  //
  // This is separate from ignore_overage_below because it tries to capture
  // the "coarseness" of the flowgroup.
  optional double ignore_overage_by_coarseness_multiplier = 4;
}

message FixedClusterHostAllocs {
  message FlowAllocAndCount {
    optional FlowAlloc alloc = 1;
    optional int32 num_hosts = 2; // number of hosts that get this alloc
  }

  // Snapshot contains a list of (allocation, count) pairs.
  //
  // If we have a snapshot of [(HIPRI = 5, num_hosts = 2), (LOPRI = 2, num_hosts = 1)],
  // then the first 2 hosts will get a HIPRI allocation of 5 and the third will get 1
  // (remaining get 0).
  //
  // Hosts are ordered consistently between runs.
  message Snapshot {
    repeated FlowAllocAndCount host_allocs = 1;
  };

  // Flow marker that identifies the cluster-level FG.
  optional FlowMarker cluster = 1;

  // Hosts in this FG will get allocs from snapshots[i % len(snapshots)] in Step i.
  repeated Snapshot snapshots = 2;
}

enum HipriThrottleConditions {
  HTC_NEVER = 0;
  HTC_WHEN_ABOVE_HIPRI_LIMIT = 1;
  HTC_WHEN_ASSIGNED_LOPRI = 2;
  HTC_ALWAYS = 3;
}

message ClusterAllocatorConfig {
  optional ClusterAllocatorType type = 1 [default = CA_BWE];
  optional bool enable_burstiness = 2 [default = true];
  optional bool enable_bonus = 3 [default = true];
  optional double oversub_factor = 4 [default = 1.15];

  optional DowngradeSelector downgrade_selector = 5;
  optional DowngradeFracController downgrade_frac_controller = 6;

  optional double heyp_acceptable_measured_ratio_over_intended_ratio = 7 [default = 0.9];
  optional bool heyp_probe_lopri_when_ambiguous = 8 [default = true];

  optional HipriThrottleConditions simple_downgrade_throttle_hipri = 9 [default = HTC_ALWAYS];

  repeated FixedClusterHostAllocs fixed_host_alloc_patterns = 10;
}

message ClusterServerConfig {
  // List of addresses to listen on.
  // Format: 0.0.0.0:1415
  repeated string addresses = 1;
  optional string control_period = 2 [default = "5s"];
}

enum ClusterControllerType {
  // CC_FULL maintains full visibility into host data and can perform
  // any combination of downgrade and rate limiting.
  CC_FULL = 0;

  // CC_FAST can only perform semi-demand oblivious downgrade
  // (rate limiting is possible but not implemented), but can scale much more
  // efficiently than CC_FULL.
  CC_FAST = 1;
};

message FastClusterControllerConfig {
  optional int32 target_num_samples = 1 [default = 200];
  optional int32 num_threads = 2 [default = 8];
  optional DowngradeFracController downgrade_frac_controller = 3;
}

message ClusterAgentConfig {
  optional ClusterControllerType controller_type = 1 [default = CC_FULL];
  optional ClusterServerConfig server = 2;

  // Only used if controller_type == CC_FULL.
  optional FlowAggregatorConfig flow_aggregator = 3;
  optional ClusterAllocatorConfig allocator = 4;

  // Only used in controller_type == CC_FAST.
  optional FastClusterControllerConfig fast_controller_config = 5;
}