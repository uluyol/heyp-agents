// This file contains definitions of all configuration protos.
// These messages should only be stored in textual or in-memory form (i.e. not
// the binary format), so feed free to change any field numbers.

syntax = "proto2";

package heyp.proto;

option go_package = "github.com/uluyol/heyp-agents/go/pb";

import "heyp/proto/heyp.proto";

message DemandPredictorConfig {
  optional string time_window_dur = 1 [default = "10s"];
  optional double usage_multiplier = 2 [default = 1.1];
  optional int64 min_demand_bps = 3 [default = 5242880];
}

message HostFlowTrackerConfig {
  optional DemandPredictorConfig demand_predictor = 1;
  optional bool ignore_instantaneous_usage = 2 [default = true];
}

message FlowAggregatorConfig {
  optional DemandPredictorConfig demand_predictor = 1;
}

message HostFlowStateReporterConfig {
  optional string ss_binary_name = 1 [default = "ss"];
}

message HostEnforcerConfig {
  // If specified, will periodically dump iptables and tc state here.
  optional string debug_log_dir = 1;
  optional bool limit_hipri = 2 [default = true];
  optional bool limit_lopri = 3 [default = true];
  optional int64 pacing_burst_bytes = 4;

  // HostEnforcer will never drop rate limits below min_rate_limit_bps.
  optional int64 min_rate_limit_bps = 5 [default = 5242880];

  optional string dscp_hipri = 6 [default = "AF21"];
  optional string dscp_lopri = 7 [default = "BE"];
}

message HostDaemonConfig {
  optional string collect_stats_period = 1 [default = "500ms"];
  optional string inform_period_dur = 2 [default = "2s"];
  optional string cluster_agent_addr = 3;
  optional string cluster_agent_connection_timeout_dur = 4 [default = "10s"];

  // Log files - will record data once per collect_stats_period.
  //
  // - stats_log_file: src/dst host-level flow data
  // - fine_grained_stats_log_file: fine grained flow data
  //
  // If unspecified, data will not be logged.
  optional string stats_log_file = 5;
  optional string fine_grained_stats_log_file = 6;
}

message DCMapping {
  message Entry {
    optional string host_addr = 1;
    optional string dc = 2;
  }
  repeated Entry entries = 1;
}

message StaticDCMapperConfig {
  optional DCMapping mapping = 1;
}

enum NetemDelayDist {
  NETEM_NO_DIST = 0;
  NETEM_NORMAL = 1;
  NETEM_UNIFORM = 2;
  NETEM_PARETO = 3;
  NETEM_PARETONORMAL = 4;
}

message NetemConfig {
  optional int32 delay_ms = 1;
  optional int32 delay_jitter_ms = 2;
  optional double delay_correlation_pct = 3;
  optional NetemDelayDist delay_dist = 4 [default = NETEM_NORMAL];
}

message SimulatedWanConfig {
  message Pair {
    optional string src_dc = 1;
    optional string dst_dc = 2;
    optional NetemConfig netem = 3;
    optional NetemConfig netem_lopri = 4; // if unspecified, defaults to netem
  }
  repeated Pair dc_pairs = 1;
}

message HostAgentConfig {
  repeated string this_host_addrs = 1;
  optional string job_name = 2 [default = "UNSET"];
  optional HostFlowTrackerConfig flow_tracker = 3;
  optional FlowAggregatorConfig socket_to_host_aggregator = 4;
  optional HostFlowStateReporterConfig flow_state_reporter = 5;
  optional HostEnforcerConfig enforcer = 6;
  optional HostDaemonConfig daemon = 7;
  optional StaticDCMapperConfig dc_mapper = 8;
  optional SimulatedWanConfig simulated_wan = 9;
}

enum ClusterAllocatorType {
  CA_NOP = 0;
  CA_BWE = 1;
  CA_HEYP_SIGCOMM20 = 2;
  CA_SIMPLE_DOWNGRADE = 3;
  CA_FIXED_HOST_PATTERN = 4;
}

enum DowngradeSelectorType {
  DS_HEYP_SIGCOMM20 = 0;
  DS_KNAPSACK_SOLVER = 1;
  DS_LARGEST_FIRST = 2;
};

message DowngradeSelector {
  optional DowngradeSelectorType type = 1 [default = DS_HEYP_SIGCOMM20];

  // If set, the DowngradeSelector will identify jobs to downgrade and mark all hosts
  // within those jobs as LOPRI.
  // Otherwise, it will select hosts without looking at which job a host belongs to.
  optional bool downgrade_jobs = 2 [default = false];
}

message FixedClusterHostAllocs {
  message FlowAllocAndCount {
    optional FlowAlloc alloc = 1;
    optional int32 num_hosts = 2; // number of hosts that get this alloc
  }

  // Snapshot contains a list of (allocation, count) pairs.
  //
  // If we have a snapshot of [(HIPRI = 5, num_hosts = 2), (LOPRI = 2, num_hosts = 1)],
  // then the first 2 hosts will get a HIPRI allocation of 5 and the third will get 1
  // (remaining get 0).
  //
  // Hosts are ordered consistently between runs.
  message Snapshot {
    repeated FlowAllocAndCount host_allocs = 1;
  };

  // Flow marker that identifies the cluster-level FG.
  optional FlowMarker cluster = 1;

  // Hosts in this FG will get allocs from snapshots[i % len(snapshots)] in Step i.
  repeated Snapshot snapshots = 2;
}

message ClusterAllocatorConfig {
  optional ClusterAllocatorType type = 1 [default = CA_BWE];
  optional bool enable_burstiness = 2 [default = true];
  optional bool enable_bonus = 3 [default = true];
  optional double oversub_factor = 4 [default = 1.15];

  optional DowngradeSelector downgrade_selector = 5;

  optional double heyp_acceptable_measured_ratio_over_intended_ratio = 6 [default = 0.9];
  optional bool heyp_probe_lopri_when_ambiguous = 7 [default = true];

  repeated FixedClusterHostAllocs fixed_host_alloc_patterns = 8;
}

message ClusterServerConfig {
  optional string address = 1 [default = "0.0.0.0:1415"];
  optional string control_period = 2 [default = "5s"];
}

message ClusterAgentConfig {
  optional FlowAggregatorConfig flow_aggregator = 1;
  optional ClusterAllocatorConfig allocator = 2;
  optional ClusterServerConfig server = 3;
}